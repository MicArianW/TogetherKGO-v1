name: Auto-Merge Pending Publish PRs (Single Deploy)

on:
  schedule:
    # Monday, Wednesday, Friday at 10:35 AM EST
    - cron: "35 14 * * 1"
    - cron: "35 14 * * 3"
    - cron: "35 14 * * 5"
  workflow_dispatch:

jobs:
  batch_merge_prs:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
      actions: write
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
      
      - name: Gather PRs with label "decap-cms/pending_publish"
        id: gather
        run: |
          prs=$(gh pr list \
            --state open \
            --label "decap-cms/pending_publish" \
            --json number,headRefName \
            --jq '.[] | "\(.number):\(.headRefName)"' | paste -sd "," -)
          
          pr_count=$(gh pr list \
            --state open \
            --label "decap-cms/pending_publish" \
            --json number \
            --jq '. | length')
          
          echo "prs=$prs" >> $GITHUB_OUTPUT
          echo "pr_count=$pr_count" >> $GITHUB_OUTPUT
          
          if [ "$pr_count" -gt 0 ]; then
            echo "Found $pr_count pending PRs to merge"
          else
            echo "No pending PRs found"
          fi
      
      - name: Batch merge all PRs into one commit
        if: steps.gather.outputs.prs != ''
        run: |
          # Parse PR numbers and branch names
          IFS=',' read -ra pr_array <<< "${{ steps.gather.outputs.prs }}"
          
          pr_numbers=""
          
          # Checkout main and pull latest
          git checkout main
          git pull origin main
          
          # Merge each PR branch (but don't push yet)
          for pr_info in "${pr_array[@]}"; do
            pr_number=$(echo "$pr_info" | cut -d':' -f1)
            branch_name=$(echo "$pr_info" | cut -d':' -f2)
            
            echo "Merging PR #$pr_number (branch: $branch_name)"
            
            # Skip workflow-changing PRs
            changed_files=$(gh pr view "$pr_number" --json files --jq '.files[].path')
            if echo "$changed_files" | grep -q '^.github/workflows/'; then
              echo "Skipping PR #$pr_number - modifies workflows"
              continue
            fi
            
            # Fetch and merge the PR branch
            git fetch origin "$branch_name"
            git merge "origin/$branch_name" --no-edit --no-ff
            
            pr_numbers="$pr_numbers #$pr_number"
          done
          
          # Push all merges as ONE commit to main
          if git diff --quiet origin/main; then
            echo "No changes to push"
            echo "merged=false" >> $GITHUB_OUTPUT
          else
            echo "Pushing batch merge of PRs:$pr_numbers"
            git push origin main
            echo "Successfully merged all PRs in one push"
            echo "merged=true" >> $GITHUB_OUTPUT
          fi
        id: merge
      
      - name: Close merged PRs
        if: steps.gather.outputs.prs != ''
        run: |
          IFS=',' read -ra pr_array <<< "${{ steps.gather.outputs.prs }}"
          
          for pr_info in "${pr_array[@]}"; do
            pr_number=$(echo "$pr_info" | cut -d':' -f1)
            
            # Close the PR (it's already merged)
            gh pr close "$pr_number" --comment "Auto-merged in batch deploy" || true
          done
      
      - name: Sync to services.json
        if: steps.merge.outputs.merged == 'true'
        run: |
          echo "Syncing approved service listings to services.json..."
          
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          // Read existing services.json (with your food banks)
          const servicesPath = 'data/services.json';
          let services = [];
          
          if (fs.existsSync(servicesPath)) {
            services = JSON.parse(fs.readFileSync(servicesPath, 'utf8'));
            console.log(`Loaded ${services.length} existing services from services.json`);
          }
          
          // Track the highest existing ID number
          let maxId = 0;
          services.forEach(service => {
            const match = service.id.match(/fb(\d+)/);
            if (match) {
              maxId = Math.max(maxId, parseInt(match[1]));
            }
          });
          
          console.log(`Highest existing ID: fb${maxId}`);
          
          // Get all approved service listing files from data/services
          const servicesDir = 'data/services';
          
          if (fs.existsSync(servicesDir)) {
            const files = fs.readdirSync(servicesDir)
              .filter(file => file.endsWith('.json') && file !== 'services.json');
            
            console.log(`Found ${files.length} service listing files`);
            
            files.forEach(file => {
              const filePath = path.join(servicesDir, file);
              const listing = JSON.parse(fs.readFileSync(filePath, 'utf8'));
              
              // Generate unique ID
              let id = file.replace('.json', '').toLowerCase().replace(/[^a-z0-9]/g, '-');
              
              // Check if this listing already exists (by name or ID)
              const existingIndex = services.findIndex(s => 
                s.name === listing.name || s.id === id
              );
              
              // If not using fb{N} format, assign next available fb ID
              if (!id.startsWith('fb')) {
                if (existingIndex === -1) {
                  maxId++;
                  id = `fb${maxId}`;
                } else {
                  id = services[existingIndex].id;
                }
              }
              
              // Create service object matching services.json format
              const serviceObj = {
                id: id,
                name: listing.name,
                type: listing.type,
                address: listing.address,
                location: {
                  lat: listing.location.lat,
                  lng: listing.location.lng
                },
                days: listing.days || [],
                hours: listing.hours,
                phone: listing.phone,
                description: listing.description,
                tags: listing.tags || []
              };
              
              // Add optional fields if they exist
              if (listing.email) serviceObj.email = listing.email;
              if (listing.website) serviceObj.website = listing.website;
              
              if (existingIndex >= 0) {
                // Update existing service
                console.log(`Updating existing service: ${listing.name} (${id})`);
                services[existingIndex] = serviceObj;
              } else {
                // Add new service
                console.log(`Adding new service: ${listing.name} (${id})`);
                services.push(serviceObj);
              }
            });
          }
          
          // Write updated services.json
          fs.writeFileSync(servicesPath, JSON.stringify(services, null, 2));
          
          console.log(`✅ Updated services.json with ${services.length} total services`);
          EOF
      
      - name: Commit services.json if changed
        if: steps.merge.outputs.merged == 'true'
        run: |
          if git diff --quiet data/services.json; then
            echo "No changes to services.json"
          else
            git add data/services.json
            git commit -m "Auto-update: Sync approved service listings to services.json"
            git push
            echo "✅ services.json updated and deployed!"
          fi
      
      - name: No PRs to merge
        if: steps.gather.outputs.prs == ''
        run: |
          echo "No pending_publish PRs found to merge"
          echo "Skipping deployment"
