name: Auto-Merge Pending Publish PRs (Single Deploy - Optimized)

on:
  schedule:
    # Monday, Wednesday, Friday at 10:35 AM EST (14:35 UTC)
    - cron: "35 14 * * 1,3,5"
  workflow_dispatch:

jobs:
  batch_merge_and_sync:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
      actions: write
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
      
      - name: Gather PRs with label "decap-cms/pending_publish"
        id: gather
        run: |
          prs=$(gh pr list \
            --state open \
            --label "decap-cms/pending_publish" \
            --json number,headRefName \
            --jq '.[] | "\(.number):\(.headRefName)"' | paste -sd "," -)
          
          pr_count=$(gh pr list \
            --state open \
            --label "decap-cms/pending_publish" \
            --json number \
            --jq '. | length')
          
          echo "prs=$prs" >> $GITHUB_OUTPUT
          echo "pr_count=$pr_count" >> $GITHUB_OUTPUT
          
          if [ "$pr_count" -gt 0 ]; then
            echo "Found $pr_count pending PRs to merge"
          else
            echo "No pending PRs found"
          fi
      
      - name: Batch merge all PRs (Don't push yet)
        if: steps.gather.outputs.prs != ''
        id: merge
        run: |
          # Parse PR numbers and branch names
          IFS=',' read -ra pr_array <<< "${{ steps.gather.outputs.prs }}"
          
          pr_numbers=""
          merged_prs=""
          
          # Checkout main and pull latest
          git checkout main
          git pull origin main
          
          # Merge each PR branch locally (but DON'T push yet)
          for pr_info in "${pr_array[@]}"; do
            pr_number=$(echo "$pr_info" | cut -d':' -f1)
            branch_name=$(echo "$pr_info" | cut -d':' -f2)
            
            echo "ğŸ”€ Merging PR #$pr_number (branch: $branch_name)"
            
            # Skip workflow-changing PRs for safety
            changed_files=$(gh pr view "$pr_number" --json files --jq '.files[].path')
            if echo "$changed_files" | grep -q '^.github/workflows/'; then
              echo "âš ï¸ Skipping PR #$pr_number - modifies workflows"
              continue
            fi
            
            # Fetch and merge the PR branch
            git fetch origin "$branch_name"
            if git merge "origin/$branch_name" --no-edit --no-ff; then
              echo "âœ… Merged PR #$pr_number"
              pr_numbers="$pr_numbers #$pr_number"
              merged_prs="$merged_prs $pr_number"
            else
              echo "âŒ Failed to merge PR #$pr_number"
            fi
          done
          
          echo "merged_prs=$merged_prs" >> $GITHUB_OUTPUT
          
          # Check if we have changes (but don't push yet)
          if git diff --quiet origin/main; then
            echo "No changes to merge"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Merged PRs:$pr_numbers (not pushed yet)"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Sync service listings to services.json
        if: steps.merge.outputs.has_changes == 'true'
        run: |
          echo "ğŸ”„ Syncing approved service listings to services.json..."
          
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          // Read existing services.json
          const servicesPath = 'data/services.json';
          let services = [];
          
          if (fs.existsSync(servicesPath)) {
            services = JSON.parse(fs.readFileSync(servicesPath, 'utf8'));
            console.log(`ğŸ“ Loaded ${services.length} existing services from services.json`);
          }
          
          // Track the highest existing ID number
          let maxId = 0;
          services.forEach(service => {
            const match = service.id.match(/fb(\d+)/);
            if (match) {
              maxId = Math.max(maxId, parseInt(match[1]));
            }
          });
          
          console.log(`ğŸ”¢ Highest existing ID: fb${maxId}`);
          
          // Get all approved service listing files from data/services
          const servicesDir = 'data/services';
          
          if (fs.existsSync(servicesDir)) {
            const files = fs.readdirSync(servicesDir)
              .filter(file => file.endsWith('.json'));
            
            console.log(`ğŸ“‚ Found ${files.length} service listing files`);
            
            files.forEach(file => {
              const filePath = path.join(servicesDir, file);
              const listing = JSON.parse(fs.readFileSync(filePath, 'utf8'));
              
              // Generate unique ID
              let id = file.replace('.json', '').toLowerCase().replace(/[^a-z0-9]/g, '-');
              
              // Check if this listing already exists (by name or ID)
              const existingIndex = services.findIndex(s => 
                s.name === listing.name || s.id === id
              );
              
              // If not using fb{N} format, assign next available fb ID
              if (!id.match(/^fb\d+$/)) {
                if (existingIndex === -1) {
                  maxId++;
                  id = `fb${maxId}`;
                } else {
                  id = services[existingIndex].id;
                }
              }
              
              // Create service object matching services.json format
              const serviceObj = {
                id: id,
                name: listing.name,
                type: listing.type || 'food_bank',
                address: listing.address,
                location: {
                  lat: parseFloat(listing.location?.lat || listing.lat || 0),
                  lng: parseFloat(listing.location?.lng || listing.lng || 0)
                },
                days: listing.days || [],
                hours: listing.hours || '',
                phone: listing.phone || '',
                description: listing.description || '',
                tags: listing.tags || []
              };
              
              // Add optional fields if they exist
              if (listing.email) serviceObj.email = listing.email;
              if (listing.website) serviceObj.website = listing.website;
              
              if (existingIndex >= 0) {
                // Update existing service
                console.log(`ğŸ”„ Updating existing service: ${listing.name} (${id})`);
                services[existingIndex] = serviceObj;
              } else {
                // Add new service
                console.log(`â• Adding new service: ${listing.name} (${id})`);
                services.push(serviceObj);
              }
            });
          }
          
          // Write updated services.json
          fs.writeFileSync(servicesPath, JSON.stringify(services, null, 2));
          
          console.log(`âœ… Updated services.json with ${services.length} total services`);
          EOF
      
      - name: Push all changes in ONE commit (Single Deploy)
        if: steps.merge.outputs.has_changes == 'true'
        run: |
          # Add services.json if it changed
          git add data/services.json
          
          # Check if there are any changes to commit
          if git diff --staged --quiet; then
            echo "No changes to services.json"
            # Just push the merged PRs
            git push origin main
            echo "âœ… Pushed merged PRs only"
          else
            # Commit services.json update
            git commit -m "Auto-update: Sync approved service listings to services.json"
            # Push everything (merged PRs + services.json) in ONE push
            git push origin main
            echo "âœ… Pushed merged PRs + services.json in ONE deployment!"
          fi
      
      - name: Close merged PRs
        if: steps.merge.outputs.merged_prs != ''
        run: |
          merged_prs="${{ steps.merge.outputs.merged_prs }}"
          
          for pr_number in $merged_prs; do
            echo "Closing PR #$pr_number"
            gh pr close "$pr_number" --comment "âœ… Auto-merged in batch deploy" || true
          done
      
      - name: Summary
        if: always()
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "WORKFLOW SUMMARY"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          
          if [ "${{ steps.gather.outputs.pr_count }}" -eq 0 ]; then
            echo "ğŸ“­ No pending PRs found"
          else
            echo "âœ… PRs found: ${{ steps.gather.outputs.pr_count }}"
            
            if [ "${{ steps.merge.outputs.has_changes }}" == "true" ]; then
              echo "âœ… Merged and synced in ONE deployment"
              echo "Netlify building (1 build only)"
            else
              echo "No changes to deploy"
            fi
          fi
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      
      - name: No PRs to merge
        if: steps.gather.outputs.prs == ''
        run: |
          echo "No pending_publish PRs found to merge"
          echo "Skipping deployment"
